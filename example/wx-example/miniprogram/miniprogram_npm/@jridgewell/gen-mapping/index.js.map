{"version":3,"sources":["gen-mapping.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));\n})(this, (function (exports, setArray, sourcemapCodec, traceMapping) { \n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n\n    const NO_NAME = -1;\n    /**\n     * Provides the state to generate a sourcemap.\n     */\n    class GenMapping {\n        constructor({ file, sourceRoot } = {}) {\n            this._names = new setArray.SetArray();\n            this._sources = new setArray.SetArray();\n            this._sourcesContent = [];\n            this._mappings = [];\n            this.file = file;\n            this.sourceRoot = sourceRoot;\n            this._ignoreList = new setArray.SetArray();\n        }\n    }\n    /**\n     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n     * with public access modifiers.\n     */\n    function cast(map) {\n        return map;\n    }\n    function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    }\n    function addMapping(map, mapping) {\n        return addMappingInternal(false, map, mapping);\n    }\n    /**\n     * Same as `addSegment`, but will only add the segment if it generates useful information in the\n     * resulting map. This only works correctly if segments are added **in order**, meaning you should\n     * not add a segment with a lower generated line/column than one that came before.\n     */\n    const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    /**\n     * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n     * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n     * not add a mapping with a lower generated line/column than one that came before.\n     */\n    const maybeAddMapping = (map, mapping) => {\n        return addMappingInternal(true, map, mapping);\n    };\n    /**\n     * Adds/removes the content of the source file to the source map.\n     */\n    function setSourceContent(map, source, content) {\n        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n        const index = setArray.put(sources, source);\n        sourcesContent[index] = content;\n    }\n    function setIgnore(map, source, ignore = true) {\n        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n        const index = setArray.put(sources, source);\n        if (index === sourcesContent.length)\n            sourcesContent[index] = null;\n        if (ignore)\n            setArray.put(ignoreList, index);\n        else\n            setArray.remove(ignoreList, index);\n    }\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function toDecodedMap(map) {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);\n        removeEmptyFinalLines(mappings);\n        return {\n            version: 3,\n            file: map.file || undefined,\n            names: names.array,\n            sourceRoot: map.sourceRoot || undefined,\n            sources: sources.array,\n            sourcesContent,\n            mappings,\n            ignoreList: ignoreList.array,\n        };\n    }\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function toEncodedMap(map) {\n        const decoded = toDecodedMap(map);\n        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });\n    }\n    /**\n     * Constructs a new GenMapping, using the already present mappings of the input.\n     */\n    function fromMap(input) {\n        const map = new traceMapping.TraceMap(input);\n        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n        putAll(cast(gen)._names, map.names);\n        putAll(cast(gen)._sources, map.sources);\n        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n        cast(gen)._mappings = traceMapping.decodedMappings(map);\n        if (map.ignoreList)\n            putAll(cast(gen)._ignoreList, map.ignoreList);\n        return gen;\n    }\n    /**\n     * Returns an array of high-level mapping objects for every recorded segment, which could then be\n     * passed to the `source-map` library.\n     */\n    function allMappings(map) {\n        const out = [];\n        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n        for (let i = 0; i < mappings.length; i++) {\n            const line = mappings[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generated = { line: i + 1, column: seg[COLUMN] };\n                let source = undefined;\n                let original = undefined;\n                let name = undefined;\n                if (seg.length !== 1) {\n                    source = sources.array[seg[SOURCES_INDEX]];\n                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                    if (seg.length === 5)\n                        name = names.array[seg[NAMES_INDEX]];\n                }\n                out.push({ generated, source, original, name });\n            }\n        }\n        return out;\n    }\n    // This split declaration is only so that terser can elminiate the static initialization block.\n    function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);\n        const line = getLine(mappings, genLine);\n        const index = getColumnIndex(line, genColumn);\n        if (!source) {\n            if (skipable && skipSourceless(line, index))\n                return;\n            return insert(line, index, [genColumn]);\n        }\n        const sourcesIndex = setArray.put(sources, source);\n        const namesIndex = name ? setArray.put(names, name) : NO_NAME;\n        if (sourcesIndex === sourcesContent.length)\n            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n            return;\n        }\n        return insert(line, index, name\n            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    }\n    function getLine(mappings, index) {\n        for (let i = mappings.length; i <= index; i++) {\n            mappings[i] = [];\n        }\n        return mappings[index];\n    }\n    function getColumnIndex(line, genColumn) {\n        let index = line.length;\n        for (let i = index - 1; i >= 0; index = i--) {\n            const current = line[i];\n            if (genColumn >= current[COLUMN])\n                break;\n        }\n        return index;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    function removeEmptyFinalLines(mappings) {\n        const { length } = mappings;\n        let len = length;\n        for (let i = len - 1; i >= 0; len = i, i--) {\n            if (mappings[i].length > 0)\n                break;\n        }\n        if (len < length)\n            mappings.length = len;\n    }\n    function putAll(setarr, array) {\n        for (let i = 0; i < array.length; i++)\n            setArray.put(setarr, array[i]);\n    }\n    function skipSourceless(line, index) {\n        // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n        // doesn't generate any useful information.\n        if (index === 0)\n            return true;\n        const prev = line[index - 1];\n        // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n        // genrate any new information. Else, this segment will end the source/named segment and point to\n        // a sourceless position, which is useful.\n        return prev.length === 1;\n    }\n    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n        // A source/named segment at the start of a line gives position at that genColumn\n        if (index === 0)\n            return false;\n        const prev = line[index - 1];\n        // If the previous segment is sourceless, then we're transitioning to a source.\n        if (prev.length === 1)\n            return false;\n        // If the previous segment maps to the exact same source position, then this segment doesn't\n        // provide any new position information.\n        return (sourcesIndex === prev[SOURCES_INDEX] &&\n            sourceLine === prev[SOURCE_LINE] &&\n            sourceColumn === prev[SOURCE_COLUMN] &&\n            namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n    }\n    function addMappingInternal(skipable, map, mapping) {\n        const { generated, source, original, name, content } = mapping;\n        if (!source) {\n            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n        }\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n    }\n\n    exports.GenMapping = GenMapping;\n    exports.addMapping = addMapping;\n    exports.addSegment = addSegment;\n    exports.allMappings = allMappings;\n    exports.fromMap = fromMap;\n    exports.maybeAddMapping = maybeAddMapping;\n    exports.maybeAddSegment = maybeAddSegment;\n    exports.setIgnore = setIgnore;\n    exports.setSourceContent = setSourceContent;\n    exports.toDecodedMap = toDecodedMap;\n    exports.toEncodedMap = toEncodedMap;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=gen-mapping.umd.js.map\n"]}