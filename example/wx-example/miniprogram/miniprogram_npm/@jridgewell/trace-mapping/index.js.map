{"version":3,"sources":["trace-mapping.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, (function (exports, sourcemapCodec, resolveUri) { \n\n    function resolve(input, base) {\n        // The base is always treated as a directory, if it's not empty.\n        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n        if (base && !base.endsWith('/'))\n            base += '/';\n        return resolveUri(input, base);\n    }\n\n    /**\n     * Removes everything after the last \"/\", but leaves the slash.\n     */\n    function stripFilename(path) {\n        if (!path)\n            return '';\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n    const REV_GENERATED_LINE = 1;\n    const REV_GENERATED_COLUMN = 2;\n\n    function maybeSort(mappings, owned) {\n        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n        if (unsortedIndex === mappings.length)\n            return mappings;\n        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n        // not, we do not want to modify the consumer's input array.\n        if (!owned)\n            mappings = mappings.slice();\n        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n            mappings[i] = sortSegments(mappings[i], owned);\n        }\n        return mappings;\n    }\n    function nextUnsortedSegmentLine(mappings, start) {\n        for (let i = start; i < mappings.length; i++) {\n            if (!isSorted(mappings[i]))\n                return i;\n        }\n        return mappings.length;\n    }\n    function isSorted(line) {\n        for (let j = 1; j < line.length; j++) {\n            if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sortSegments(line, owned) {\n        if (!owned)\n            line = line.slice();\n        return line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[COLUMN] - b[COLUMN];\n    }\n\n    let found = false;\n    /**\n     * A binary search implementation that returns the index if a match is found.\n     * If no match is found, then the left-index (the index associated with the item that comes just\n     * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n     * the next index:\n     *\n     * ```js\n     * const array = [1, 3];\n     * const needle = 2;\n     * const index = binarySearch(array, needle, (item, needle) => item - needle);\n     *\n     * assert.equal(index, 0);\n     * array.splice(index + 1, 0, needle);\n     * assert.deepEqual(array, [1, 2, 3]);\n     * ```\n     */\n    function binarySearch(haystack, needle, low, high) {\n        while (low <= high) {\n            const mid = low + ((high - low) >> 1);\n            const cmp = haystack[mid][COLUMN] - needle;\n            if (cmp === 0) {\n                found = true;\n                return mid;\n            }\n            if (cmp < 0) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        found = false;\n        return low - 1;\n    }\n    function upperBound(haystack, needle, index) {\n        for (let i = index + 1; i < haystack.length; index = i++) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function lowerBound(haystack, needle, index) {\n        for (let i = index - 1; i >= 0; index = i--) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function memoizedState() {\n        return {\n            lastKey: -1,\n            lastNeedle: -1,\n            lastIndex: -1,\n        };\n    }\n    /**\n     * This overly complicated beast is just to record the last tested line/column and the resulting\n     * index, allowing us to skip a few tests if mappings are monotonically increasing.\n     */\n    function memoizedBinarySearch(haystack, needle, state, key) {\n        const { lastKey, lastNeedle, lastIndex } = state;\n        let low = 0;\n        let high = haystack.length - 1;\n        if (key === lastKey) {\n            if (needle === lastNeedle) {\n                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n                return lastIndex;\n            }\n            if (needle >= lastNeedle) {\n                // lastIndex may be -1 if the previous needle was not found.\n                low = lastIndex === -1 ? 0 : lastIndex;\n            }\n            else {\n                high = lastIndex;\n            }\n        }\n        state.lastKey = key;\n        state.lastNeedle = needle;\n        return (state.lastIndex = binarySearch(haystack, needle, low, high));\n    }\n\n    // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n    // of generated line/column.\n    function buildBySources(decoded, memos) {\n        const sources = memos.map(buildNullArray);\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                if (seg.length === 1)\n                    continue;\n                const sourceIndex = seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                const originalSource = sources[sourceIndex];\n                const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n                const memo = memos[sourceIndex];\n                // The binary search either found a match, or it found the left-index just before where the\n                // segment should go. Either way, we want to insert after that. And there may be multiple\n                // generated segments associated with an original location, so there may need to move several\n                // indexes before we find where we need to insert.\n                let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n                memo.lastIndex = ++index;\n                insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n            }\n        }\n        return sources;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n    // order when iterating with for-in.\n    function buildNullArray() {\n        return { __proto__: null };\n    }\n\n    const AnyMap = function (map, mapUrl) {\n        const parsed = parse(map);\n        if (!('sections' in parsed)) {\n            return new TraceMap(parsed, mapUrl);\n        }\n        const mappings = [];\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        const ignoreList = [];\n        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n        const joined = {\n            version: 3,\n            file: parsed.file,\n            names,\n            sources,\n            sourcesContent,\n            mappings,\n            ignoreList,\n        };\n        return presortedDecodedMap(joined);\n    };\n    function parse(map) {\n        return typeof map === 'string' ? JSON.parse(map) : map;\n    }\n    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n        const { sections } = input;\n        for (let i = 0; i < sections.length; i++) {\n            const { map, offset } = sections[i];\n            let sl = stopLine;\n            let sc = stopColumn;\n            if (i + 1 < sections.length) {\n                const nextOffset = sections[i + 1].offset;\n                sl = Math.min(stopLine, lineOffset + nextOffset.line);\n                if (sl === stopLine) {\n                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n                }\n                else if (sl < stopLine) {\n                    sc = columnOffset + nextOffset.column;\n                }\n            }\n            addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n        }\n    }\n    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n        const parsed = parse(input);\n        if ('sections' in parsed)\n            return recurse(...arguments);\n        const map = new TraceMap(parsed, mapUrl);\n        const sourcesOffset = sources.length;\n        const namesOffset = names.length;\n        const decoded = decodedMappings(map);\n        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n        append(sources, resolvedSources);\n        append(names, map.names);\n        if (contents)\n            append(sourcesContent, contents);\n        else\n            for (let i = 0; i < resolvedSources.length; i++)\n                sourcesContent.push(null);\n        if (ignores)\n            for (let i = 0; i < ignores.length; i++)\n                ignoreList.push(ignores[i] + sourcesOffset);\n        for (let i = 0; i < decoded.length; i++) {\n            const lineI = lineOffset + i;\n            // We can only add so many lines before we step into the range that the next section's map\n            // controls. When we get to the last line, then we'll start checking the segments to see if\n            // they've crossed into the column range. But it may not have any columns that overstep, so we\n            // still need to check that we don't overstep lines, too.\n            if (lineI > stopLine)\n                return;\n            // The out line may already exist in mappings (if we're continuing the line started by a\n            // previous section). Or, we may have jumped ahead several lines to start this section.\n            const out = getLine(mappings, lineI);\n            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n            // map can be multiple lines), it doesn't.\n            const cOffset = i === 0 ? columnOffset : 0;\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const column = cOffset + seg[COLUMN];\n                // If this segment steps into the column range that the next section's map controls, we need\n                // to stop early.\n                if (lineI === stopLine && column >= stopColumn)\n                    return;\n                if (seg.length === 1) {\n                    out.push([column]);\n                    continue;\n                }\n                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                out.push(seg.length === 4\n                    ? [column, sourcesIndex, sourceLine, sourceColumn]\n                    : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n            }\n        }\n    }\n    function append(arr, other) {\n        for (let i = 0; i < other.length; i++)\n            arr.push(other[i]);\n    }\n    function getLine(arr, index) {\n        for (let i = arr.length; i <= index; i++)\n            arr[i] = [];\n        return arr[index];\n    }\n\n    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n    const LEAST_UPPER_BOUND = -1;\n    const GREATEST_LOWER_BOUND = 1;\n    class TraceMap {\n        constructor(map, mapUrl) {\n            const isString = typeof map === 'string';\n            if (!isString && map._decodedMemo)\n                return map;\n            const parsed = (isString ? JSON.parse(map) : map);\n            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n            this.version = version;\n            this.file = file;\n            this.names = names || [];\n            this.sourceRoot = sourceRoot;\n            this.sources = sources;\n            this.sourcesContent = sourcesContent;\n            this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n            const { mappings } = parsed;\n            if (typeof mappings === 'string') {\n                this._encoded = mappings;\n                this._decoded = undefined;\n            }\n            else {\n                this._encoded = undefined;\n                this._decoded = maybeSort(mappings, isString);\n            }\n            this._decodedMemo = memoizedState();\n            this._bySources = undefined;\n            this._bySourceMemos = undefined;\n        }\n    }\n    /**\n     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n     * with public access modifiers.\n     */\n    function cast(map) {\n        return map;\n    }\n    /**\n     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n     */\n    function encodedMappings(map) {\n        var _a;\n        var _b;\n        return ((_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : (_b._encoded = sourcemapCodec.encode(cast(map)._decoded)));\n    }\n    /**\n     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n     */\n    function decodedMappings(map) {\n        var _a;\n        return ((_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded)));\n    }\n    /**\n     * A low-level API to find the segment associated with a generated line/column (think, from a\n     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n     */\n    function traceSegment(map, line, column) {\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return null;\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n        return index === -1 ? null : segments[index];\n    }\n    /**\n     * A higher-level API to find the source/line/column associated with a generated line/column\n     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n     * `source-map` library.\n     */\n    function originalPositionFor(map, needle) {\n        let { line, column, bias } = needle;\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1)\n            return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1)\n            return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    }\n    /**\n     * Finds the generated line/column position of the provided source/line/column source position.\n     */\n    function generatedPositionFor(map, needle) {\n        const { source, line, column, bias } = needle;\n        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    }\n    /**\n     * Finds all generated line/column positions of the provided source/line/column source position.\n     */\n    function allGeneratedPositionsFor(map, needle) {\n        const { source, line, column, bias } = needle;\n        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    }\n    /**\n     * Iterates each mapping in generated position order.\n     */\n    function eachMapping(map, cb) {\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5)\n                    name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name,\n                });\n            }\n        }\n    }\n    function sourceIndex(map, source) {\n        const { sources, resolvedSources } = map;\n        let index = sources.indexOf(source);\n        if (index === -1)\n            index = resolvedSources.indexOf(source);\n        return index;\n    }\n    /**\n     * Retrieves the source content for a particular source, if its found. Returns null if not.\n     */\n    function sourceContentFor(map, source) {\n        const { sourcesContent } = map;\n        if (sourcesContent == null)\n            return null;\n        const index = sourceIndex(map, source);\n        return index === -1 ? null : sourcesContent[index];\n    }\n    /**\n     * Determines if the source is marked to ignore by the source map.\n     */\n    function isIgnored(map, source) {\n        const { ignoreList } = map;\n        if (ignoreList == null)\n            return false;\n        const index = sourceIndex(map, source);\n        return index === -1 ? false : ignoreList.includes(index);\n    }\n    /**\n     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n     * maps.\n     */\n    function presortedDecodedMap(map, mapUrl) {\n        const tracer = new TraceMap(clone(map, []), mapUrl);\n        cast(tracer)._decoded = map.mappings;\n        return tracer;\n    }\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function decodedMap(map) {\n        return clone(map, decodedMappings(map));\n    }\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function encodedMap(map) {\n        return clone(map, encodedMappings(map));\n    }\n    function clone(map, mappings) {\n        return {\n            version: map.version,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings,\n            ignoreList: map.ignoreList || map.x_google_ignoreList,\n        };\n    }\n    function OMapping(source, line, column, name) {\n        return { source, line, column, name };\n    }\n    function GMapping(line, column) {\n        return { line, column };\n    }\n    function traceSegmentInternal(segments, memo, line, column, bias) {\n        let index = memoizedBinarySearch(segments, column, memo, line);\n        if (found) {\n            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n        }\n        else if (bias === LEAST_UPPER_BOUND)\n            index++;\n        if (index === -1 || index === segments.length)\n            return -1;\n        return index;\n    }\n    function sliceGeneratedPositions(segments, memo, line, column, bias) {\n        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n        // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n        // match LEAST_UPPER_BOUND.\n        if (!found && bias === LEAST_UPPER_BOUND)\n            min++;\n        if (min === -1 || min === segments.length)\n            return [];\n        // We may have found the segment that started at an earlier column. If this is the case, then we\n        // need to slice all generated segments that match _that_ column, because all such segments span\n        // to our desired column.\n        const matchedColumn = found ? column : segments[min][COLUMN];\n        // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n        if (!found)\n            min = lowerBound(segments, matchedColumn, min);\n        const max = upperBound(segments, matchedColumn, min);\n        const result = [];\n        for (; min <= max; min++) {\n            const segment = segments[min];\n            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n        }\n        return result;\n    }\n    function generatedPosition(map, source, line, column, bias, all) {\n        var _a;\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return all ? [] : GMapping(null, null);\n        const generated = ((_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), (cast(map)._bySourceMemos = sources.map(memoizedState)))));\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return all ? [] : GMapping(null, null);\n        const memo = cast(map)._bySourceMemos[sourceIndex];\n        if (all)\n            return sliceGeneratedPositions(segments, memo, line, column, bias);\n        const index = traceSegmentInternal(segments, memo, line, column, bias);\n        if (index === -1)\n            return GMapping(null, null);\n        const segment = segments[index];\n        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n\n    exports.AnyMap = AnyMap;\n    exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n    exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n    exports.TraceMap = TraceMap;\n    exports.allGeneratedPositionsFor = allGeneratedPositionsFor;\n    exports.decodedMap = decodedMap;\n    exports.decodedMappings = decodedMappings;\n    exports.eachMapping = eachMapping;\n    exports.encodedMap = encodedMap;\n    exports.encodedMappings = encodedMappings;\n    exports.generatedPositionFor = generatedPositionFor;\n    exports.isIgnored = isIgnored;\n    exports.originalPositionFor = originalPositionFor;\n    exports.presortedDecodedMap = presortedDecodedMap;\n    exports.sourceContentFor = sourceContentFor;\n    exports.traceSegment = traceSegment;\n\n}));\n//# sourceMappingURL=trace-mapping.umd.js.map\n"]}